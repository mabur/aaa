<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Auxiliary Arithmetic Algorithms: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Auxiliary Arithmetic Algorithms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Auxiliary Arithmetic Algorithms Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Contents</h1>
<ul>
<li>Overview</li>
<li>Requirements</li>
<li>Design and Rationale</li>
<li>Building</li>
<li>Examples</li>
</ul>
<h1>Overview</h1>
<p>This library consists of a set of templated functions for doing basic arithmetic operations on containers and ranges of iterators. The elements of the ranges/containers can be any built in aritmetic type, e.g. <code>float</code>, <code>double</code>, <code>int</code>, or any other type that supports the arithmetic operations: +, -, *, /. We refer to a range/container of arithmetic elements as a mathematical vector. This library defines vector operations for arbitrary finite vector spaces. This library does not define any specific data structure for the vectors, but operates on general vectors/ranges/containers.</p>
<p>The library consists of different modules:</p><ul>
<li><a class="el" href="group__vector__space.html">Vector Spaces</a>. This module defines elementwise arithmetic operations on vectors. It consists of the functions: <a class="el" href="group__add.html">add</a>, <a class="el" href="group__subtract.html">subtract</a>, <a class="el" href="group__negate.html">negate</a>, <a class="el" href="group__multiply.html">multiply</a>, <a class="el" href="group__divide.html">divide</a>.</li>
<li><a class="el" href="group__norms__metrics.html">Normed and Metric Spaces</a>. This module defines norms/lengths and metrics/distances for vectors. These functions take one or two vectors and returns a single scalar. It consists of the functions: <code>dot</code>, <code>norm</code>, <code>distance</code>, <code>squared_norm</code>, <code>squared_distance</code>. They are defined for the following vector spaces: <a class="el" href="group__euclidean__space.html">Euclidean Space (L-2)</a>, <a class="el" href="group__manhattan__space.html">Manhattan Space (L-1)</a>, <a class="el" href="group__maximum__space.html">Maximum Space (L-Infinity)</a>.</li>
<li><a class="el" href="group__misc__algorithms.html">Misc Operations</a>. This contains the functions: <code>sum</code>, <code>convert</code>.</li>
<li><a class="el" href="group__logical.html">Logical Operations</a>. This module defines elementwise boolean operations on ranges/containers. The elements should be of type <code>bool</code>, or any other type that supports the the boolean operations &amp;&amp;, ||, !. The module contains the functions: <a class="el" href="group__logical__and.html">logical_and</a>, <a class="el" href="group__logical__or.html">logical_or</a>, <a class="el" href="group__logical__not.html">logical_not</a>.</li>
<li><a class="el" href="group__std__algorithms__container.html">STD Algorithms on Containers</a>. This module defines container versions of some range algorithms from the standard library header <a href="http://www.cplusplus.com/reference/algorithm/">algorithm</a>. It only does it for the algorithms that are used a lot for arithmetic types. It contains the functions: <code>fill</code>, <code>copy</code>, <code>min_element</code>, <code>max_element</code>, <code>minmax_element</code>.</li>
</ul>
<h1>Requirements</h1>
<p>All the functions of this library assume that the input and output is:</p><ul>
<li>Either ranges of iterators, or standard like containers, i.e. they have begin and end functions that give iterators.</li>
<li>The elements of the ranges/containers should support arithmetic operations: +, -, *, /. The functions in the module <em>Logical Operations</em> is the only exception to this. It assumes that the elements support the boolean operations &amp;&amp;, ||, !.</li>
<li>The functions in the norms and metrics module assume that the default construction of a scalar gives zero, which is true for the built-in arithmetic types. The function <code>sum</code> also assumes this.</li>
</ul>
<h1>Design and Rationale</h1>
<p>This library deals with arithmetic operations on mathematical vectors, represented as ranges or containers. It is designed for vectors in arbitrary dimensions. It is NOT optimized for small vectors, which you typically use to represent geometry in 2D and 3D. For that use case it might be more optimal to use other libraries like: <a href="http://glm.g-truc.net/">GLM</a> and <a href="http://eigen.tuxfamily.org/">Eigen</a>.</p>
<p>C++ libraries that deals with mathematical vectors in arbitrary dimensions can usually be divided into two categories:</p><ol type="1">
<li>Those that implement a vector class and overload its arithmetic operators. Examples of this are: <a href="http://www.cplusplus.com/reference/valarray/">std::valarray</a>, <a href="http://eigen.tuxfamily.org/">Eigen</a>, <a href="https://sourceforge.net/projects/blitz/">Blitz++</a>, <a href="http://opencv.org/">OpenCV</a>.</li>
<li>Those that implement general algorithms that work on any container or range of iterators. An example of this is the standard library and the headers <a href="http://www.cplusplus.com/reference/algorithm/">algorithm</a> and <a href="http://www.cplusplus.com/reference/numeric/">numeric</a>.</li>
</ol>
<p>This library follows the second approach. It implements some common arithmetic algorithms that are missing in the standard library.</p>
<p>The two approaches have different advantages and disadvantages:</p><ol type="1">
<li>The advantage of the first approach is that the syntax can be very concise, when you overload the arithmetic operators to act directly on the vector class. This approach can also have performance advantages, since it couples the algorithm to the data structure. It is then possible to use techniques like <em>expression templates</em> or <em>aligned memory</em> and <em>vectorization</em>.</li>
<li>The advantage of the second approach is that it allows <em>generic programming</em>. Code that uses such libraries is more general since it is less coupled to a specific data structure. This is good for readability and reuse of the code.</li>
</ol>
<h1>Building</h1>
<p>The library is header only, which makes it easy to use and build. Download it and add it to the include directory of your project and <code>#include &lt;<a class="el" href="aaa_8hpp_source.html">aaa.hpp</a>&gt;</code>.</p>
<h1>Examples</h1>
<p>The algorithms can be used on arbitrary containers like this: </p><div class="fragment"><div class="line"><span class="comment">// Blend two images.</span></div><div class="line">Image blend(<span class="keyword">const</span> Image&amp; in1, <span class="keyword">const</span> Image&amp; in2)</div><div class="line">{</div><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespaceaaa.html">aaa</a>;</div><div class="line">    <span class="keyword">auto</span> a = add(in1, in2); <span class="comment">// Add the images together elementwise.</span></div><div class="line">    <span class="keywordflow">return</span> divide(a, 2); <span class="comment">// Divide the result elementwise with 2 to get the mean image.</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Returns the projection of a on b.</span></div><div class="line">std::vector&lt;float&gt; project(<span class="keyword">const</span> std::vector&lt;float&gt;&amp; a, <span class="keyword">const</span> std::vector&lt;float&gt;&amp; b)</div><div class="line">{</div><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespaceaaa.html">aaa</a>;</div><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespaceaaa_1_1euclidean.html">aaa::euclidean</a>;</div><div class="line">    <span class="comment">// First we compute the scaling factor of the projection by taking the dot</span></div><div class="line">    <span class="comment">// product of the vectors. We normalize with the squared_norm of the vector</span></div><div class="line">    <span class="comment">// that we are projecting on.</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> scaling = dot(a, b) / squared_norm(b);</div><div class="line">    <span class="comment">// The projection of a on b is like b,</span></div><div class="line">    <span class="comment">// but multiplied elementwise with the scaling factor.</span></div><div class="line">    <span class="keywordflow">return</span> multiply(scaling, b);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
